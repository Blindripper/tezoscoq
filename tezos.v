From mathcomp.ssreflect
  Require Import ssreflect ssrfun ssrbool ssrnat seq.
From Coq
  Require Import ZArith String List.
Import ListNotations.

Set Implicit Arguments.

Section Data.

Inductive tez := Tez : nat -> tez.

(* for now, many items are commented as we are trying to get the
architecture right and don't want to get clogged with very similar
cases over and over. As we get more confident that we got things
right, we will uncomment new elements *)

Inductive tagged_data:=
      | Int8 : Z -> tagged_data
      (* | Int16 : Z -> tagged_data *)
      (* | Int32 : Z -> tagged_data *)
      (* | Int64 : Z -> tagged_data *)
      (* | Uint8 : Z -> tagged_data *)
      (* | Uint16 : Z -> tagged_data *)
      (* | Uint32 : Z -> tagged_data *)
      (* | Uint64 : Z -> tagged_data *)
      | Void
      | Dtrue
      | Dfalse
      | DString : string -> tagged_data
      (* | <float constant> *)
      (* | Timestamp <timestamp constant> *)
      (* | Signature <signature constant> *)
      | DTez : tez -> tagged_data.
      (* | Key <key constant> *)
      (* | Left <tagged data> <type> *)
      (* | Right <type> <tagged data> *)
      (* | Or <type> <type> <untagged data> *)
      (* | Ref <tagged data> *)
      (* | Ref <type> <untagged data> *)
      (* | Some <tagged data> *)
      (* | Some <type> <untagged data> *)
      (* | None <type> *)
      (* | Option <type> <untagged data> *)
      (* | Pair <tagged data> <tagged data> *)
      (* | Pair <type> <type> <untagged data> <untagged data> *)
      (* | List <type> <untagged data> ... *)
      (* | Set <comparable type> <untagged data> ... *)
      (* | Map <comparable type> <type> (Item <untagged data> <untagged data>) ... *)
      (* | Contract <type> <type> <contract constant> *)
      (* | Lambda <type> <type> { <instruction> ... } *)


Definition stack := list tagged_data.

End Data.

Section Instructions.

(* In what follows, the "nested inductive types" approach calls for a custom (user-defined) induction principle *)

(* XXX: should we use a notation for `list instr` here? *)
Inductive instr :=
| Drop : instr
| If : list instr -> list instr -> instr
| Loop : list instr -> instr.

Definition instructions := list instr.

(* The custom induction principle for the `instr` datatype.
 *  We need it because the autogenerated `instr_ind` is too
 * weak for proofs.
 * Based on the approach described in
 * "Certified Programming with Dependent Types" book by A. Chlipala:
 * http://adam.chlipala.net/cpdt/html/InductiveTypes.html#lab32
 *)
Variable P : instr -> Prop.
Hypothesis Drop_case : P Drop.
Hypothesis If_case : forall ins1 ins2 : instructions,
    Forall P ins1 -> Forall P ins2 -> P (If ins1 ins2).
Hypothesis Loop_case : forall ins : instructions,
    Forall P ins -> P (Loop ins).
Fixpoint instr_ind' (i : instr) : P i :=
  let list_instr_ind :=
      (fix list_instr_ind (ins : instructions) : Forall P ins :=
         match ins with
         | [] => Forall_nil _
         | i' :: ins' => Forall_cons _ (instr_ind' i') (list_instr_ind ins')
         end) in
  match i with
    | Drop => Drop_case
    | If ins1 ins2 => If_case (list_instr_ind ins1) (list_instr_ind ins2)
    | Loop ins => Loop_case (list_instr_ind ins)
    end.
End Instructions.

Section Types.

Inductive type :=
| t_int8 : type
| t_void : type
| t_bool : type
| t_string : type
| t_tez : tez -> type
| t_contract : type -> type -> type
| t_var : nat -> type
| t_anon : type.

Inductive stack_type :=
| empty_stack : stack_type
| cons_stack : type -> stack_type -> stack_type
| stack_var : nat -> stack_type
| stack_anon : stack_type.

Inductive instr_type :=
  Pre_post : stack_type -> stack_type -> instr_type.

End Types.

Section Typing.
(* Here we want to talk about typing judgements, for data,
instructions and programs *)

(* FIXME: this is obviously not what we want here:
- notations are needed
- variables indexed by nats are not satisfying
 *)
Fixpoint get_instr_type (i : instr) : option instr_type :=
  match i with
    | Drop => Some (Pre_post (cons_stack t_anon (stack_var 0)) (stack_var 0))
    | If bt bf => Some (Pre_post (cons_stack t_bool (cons_stack (t_var 0) (stack_var 0))) (cons_stack (t_var 1) (stack_var 0)))
      (* Some (Pre_post) *)
    | _ => (* TODO *) None
  end.

End Typing.

Section Semantics.

(* To be changed once we know what we want *)
Variables memory : Type.

(* until we get a better sense of what works best, we will try two
ways to do the small steps semantics: one with an inductive type of
reduction rules, and one with a step function. *)

(* First version: inductive semantics *)
Section Ind_semantics.

Inductive step : instr * instructions * stack * memory ->
                 instructions * stack * memory -> Prop :=
| stepDrop : forall ins x s m, step (Drop, ins, x::s, m)
                               (ins, s, m)
| stepIfTrue : forall cont insT insF s m,
    step (If insT insF, cont, Dtrue :: s, m)
         (insT ++ cont, s, m)
| stepIfFalse : forall cont insT insF s m,
    step (If insT insF, cont, Dfalse :: s, m)
         (insF ++ cont, s, m)
| stepLoopGo : forall cont body s m,
    step (Loop body, cont, Dtrue :: s, m)
         (body ++ (Loop body :: cont), s, m)
| stepLoopEnd : forall cont body s m,
    step (Loop body, cont, Dfalse :: s, m)
         (cont, s, m)
.

End Ind_semantics.


(* Second version: with a step function *)
Section Fun_semantics.

Fixpoint step_fun (i : instr) (ix : instructions) (s : stack) (m : memory) : option (instructions * stack * memory) :=
  match i with
    | Drop => if s is x::xs then Some(ix,xs,m) else None
    | If bt bf => if s is x::xs then
                    match x with
                      | Dtrue => Some(bt++ix,s,m)
                      | Dfalse => Some(bf++ix,s,m)
                      | _ => None
                    end else None
    | Loop body => if s is x::xs then
                  match x with
                    | Dtrue => Some(body++(Loop body :: ix),s,m)
                    | Dfalse => Some(ix,s,m)
                    | _ => None
                  end else None
  end.

End Fun_semantics.

End Semantics.